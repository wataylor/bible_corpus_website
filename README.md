# A web site for displaying any mixture of more than 100 different Bible translations #

The .war file produced by this repository supports the web site generated by the companion repository **oneBibleTranslation**.  Both of these repositories are deployed; see:

**http://perennitypublishing.com/corpus/**
**http://perennitypublishing.com/1/**

## Usage and Overview ##

**index.html** has a set of radio buttons which specifies which
translation language comes first and a set of check boxes which select additional translations.  The reference box accepts a Bible reference like Ge. 1:1-10 which tells what passage to display for the selected language(s).

Book abbreviations are listed in the java map **bookNumbers** in **asst.corpus.utils.BookNameAbbrevMap**.  The map shows that both **Ge.** and **Genesis** map to book 1, the first book of the Bible.  These abbreviations must also be listed in the JavaScript file **bookNames.js**.

The radio buttons and checkboxes in **index.html** display a human-readable name of the translation and return a database-friendly string which identifies the database table and column name where verses for that translation are stored.

Data are stored in MySQL because it's a widely-used free database.  MySQL has a row length limit of 65,535 bytes.  Verses are stored in UTF8 which takes a variable number of bytes per character and some verses are long, so only 5 Bibles are stored in each table.

The Java map **LANG_2_TABLE** in the class **asst.MapLanguagesToTables** shows how names are mapped.  Whenever a new translation is added, this table must be updated as well as the radio buttons and checkboxes in **index.html**.

This table maps the human-readable string "**KJV English**" to the column description "**0.KJVEnglish**."  This tells the software that verses for the **KJV English** translation are stored in column **KJVEnglish** of table **text0**.

These tables are indexed by 3-letter book code or book number, chapter, and verse.  "**Arabic**" maps to "**1.Arabic**."  If the radio button for Arabic is selected, the reference Ge. 1:1-10 maps to the query

**select Arabic from text1 where Book=1 and Chapter=1 and Verse >=1 and Verse <= 10**

and Genesis 1:1**,**10 maps to

**select Arabic from text1 where Book=1 and Chapter=1 and Verse =1 or Verse = 10**

If multiple translations are selected by checking boxes, the query joins as many tables as needed to retrieve all the translations.  The **where** clause selects verses as shown above and additional clauses join the tables on book, chapter, and verse.

If a translation is missing a verse, the engine shows "Verse missing."

## Data Structures ##

Book numbers from 1-66 are mapped to English book names in a Java String array **FormalBookNames** in **asst.corpus.utils.BookNameAbbrevMap** whose indexes 1-66 select a book name.

This Java class also has a Java String array **BookChaptersAndVerses** which contains a JavaScript integer array for each book name.  The number of integers gives the number of chapters in the book and each integer gives the number of verses in the chapter.

For example, **BookChaptersAndVerses[8]** for the book of Ruth is **"[22,23,18,22]"**.  There are 4 integers in the JavaScript array because the Book of Ruth has 4 chapters.  Ruth Chapter 1 has 22 verses, Ruth Chapter 2 has 23 verses and so on.  This array is used to generate Book, Chapter and Verse pulldowns for the book of Ruth when displaying an entire Bible in an .html file.

## Database Tables ##

The Database has tables named text0, text1, ..., text22  which store verses of the Bible as indexed by 3-letter book code or book number, chapter number, and verse number.  The column names for verse text match the file names from the corpus with special characters translated to underscores.

For example, the translation **K'iche'-NT-SIL** maps to  **10.K_iche__NT_SIL** because that translation fell into table 10 and neither **'** nor **-** are acceptable characters in MySQL column names.

The repository includes a file **aText.sql** which creates and initializes a table to hold 5 more translations.  After creating the table, the script initializes one row for each of the 31102 verses of the Bible.  These rows are indexed by a primary key ID, the three-letter code GEN, EXO, etc. and a unique key Book, Chapter, Verse:

  PRIMARY KEY (`ID`),
  UNIQUE KEY `col` (`Code`,`Chapter`,`Verse`),
  UNIQUE KEY `bok` (`Book`,`Chapter`,`Verse`)

The table name is set to **text99** in the file so that it will not conflict with an existing table.  *Be sure* to change all instances of text99 to whatever table name you want to create.  Add columns for each translation:

**alter table text<number> add column <translation> mediumtext CHARACTER SET utf8;**

Specifying the character set is important.

A program which reads data to insert a verse for a new translation uses SQL **update** statements like

**update text<number> set <column name> = '<verse text>' where Book = x and Chapter = Y and Verse = Z**

The Java classes **BinaryQuote** and **Quotable** in package **asst.dbase** convert special characters for use in SQL statements.

## Utility Programs ##

The system for preparing the database has the following programs:

### ReadAnyXmlFile ###

This program is intended for exploring an XML file.  It reads a file and  prints out the name and text content for each element in the document along with the names and values of all attributes.

### JavaXlmParseMain ###

This program reads a corpus file and prints the text content and attributes of all the SEG elements.  It is a more specific version of the program that reads any XML file.

### BuildColumnsAndRadiosMain ###

Reads all of the corpus file names and creates **alter table add column statements** to add a column for each Bible to the appropriate table.

It also generates a set of radio buttons so that each translation can be selected as the first in a table of verses and a set of checkboxes so that each translation can be selected for inclusion in a multi-translation table.

### LoadCorpusBibleFilesMain ###

Generates an **update** statement for each verse in the corpus.  The statements set the value of the appropriate column of the appropriate table based on 3-letter book code, chapter number, and verse number.

Updates are split into different files. Each file has updates for each table which holds 5 Bibles.

The program also writes an error file for each Bible file that specifies verses that do not exist.  For example,
the Piate Bible supplies a text string for verse **3JO.1.15** but 3rd John doesn't have verse 15, it ends with verse 14.